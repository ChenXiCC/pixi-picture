{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/HardLightShader.js","pixi-picture.min.js","src/OverlayShader.js","src/PictureRenderer.js","src/PictureShader.js","src/PictureSprite.js","src/index","src/mapFilterBlendModesToPixi.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","OverlayShader","gl","PIXI","Shader","this","bind","uniforms","uSampler","prototype","Object","create","constructor","2","3","PictureRenderer","renderer","ObjectRenderer","nextPow2","v","PictureShader","mapFilterBlendModesToPixi","glCore","onContextChange","quad","Quad","normalShader","drawModes","initVao","_tempClamp","Float32Array","_tempColor","_tempRect","Rectangle","_tempRect2","_tempRect3","_tempMatrix","Matrix","_bigBuf","Uint8Array","_renderTexture","BaseRenderTexture","start","flush","_getRenderTexture","minWidth","minHeight","width","height","resize","_getBuf","size","buf","render","sprite","texture","valid","blendShader","blendMode","_renderBlend","_renderNormal","shader","bindShader","state","setBlendMode","_renderInner","spriteBounds","getBounds","renderTarget","_activeRenderTarget","matrix","projectionMatrix","flipX","flipY","d","resolution","screen","fr","sourceFrame","destinationFrame","x","y","bounds","fbw","fbh","tx","ty","x_1","Math","floor","max","x_2","ceil","min","y_1","y_2","pixelsWidth","pixelsHeight","rt","bindTexture","renderingToScreen","root","readPixels","RGBA","UNSIGNED_BYTE","texSubImage2D","TEXTURE_2D","copyTexSubImage2D","BLEND_MODES","NORMAL","mapMatrix","toArray","uvs","_uvs","vd","vertices","computedGeometry","vertexData","x0","y0","x1","y1","x2","y2","x3","y3","upload","frame","base","baseTexture","clamp","realWidth","uTextureClamp","color","utils","hex2rgb","tint","alpha","worldAlpha","uColor","draw","WebGLRenderer","registerPlugin","./PictureShader","./mapFilterBlendModesToPixi","4","5","PictureSprite","Sprite","_renderWebGL","updateGeometry","setObjectRenderer","plugins","picture","6","myPlugin","assign","extras","./PictureRenderer","./PictureSprite","7","array","CONST","OVERLAY","HARD_LIGHT","HardLightShader","./HardLightShader","./OverlayShader"],"mappings":"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","file":"pixi-picture.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.tilemap\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n */\r\nfunction OverlayShader(gl)\r\n{\r\n    PIXI.Shader.call(this,\r\n        gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nuniform mat3 mapMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvarying vec2 vMapCoord;\\n\\nvoid main(void)\\n\\n{\\n\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\\n\\n    vTextureCoord = aTextureCoord;\\n\\n}\\n\\n\",\r\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying vec2 vMapCoord;\\n\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\n\\nuniform vec4 uTextureClamp;\\n\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n\\n{\\n\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n\\n    vec4 source = texture2D(uSampler[0], textureCoord);\\n\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\r\\n    //yeah, premultiplied\\r\\n    if (source.a == 0.0) {\\n\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n\\n        return;\\n\\n    }\\n\\n    vec3 Cb = source.rgb/source.a, Cs;\\n\\n    if (target.a > 0.0) {\\n\\n        Cs = target.rgb / target.a;\\n\\n    }\\n\\n    vec3 multiply = Cb * Cs * 2.0;\\n\\n    vec3 Cs2 = Cs * 2.0 - 1.0;\\n\\n    vec3 screen = Cb + Cs2 - Cb * Cs2;\\n\\n    vec3 B;\\n\\n    if (Cb.r <= 0.5) {\\n\\n        B.r = multiply.r;\\n\\n    } else {\\n\\n        B.r = screen.r;\\n\\n    }\\n\\n    if (Cb.g <= 0.5) {\\n\\n        B.g = multiply.g;\\n\\n    } else {\\n\\n        B.g = screen.g;\\n\\n    }\\n\\n    if (Cb.b <= 0.5) {\\n\\n        B.b = multiply.b;\\n\\n    } else {\\n\\n        B.b = screen.b;\\n\\n    }\\n\\n    vec4 res;\\n\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n\\n    res.a = source.a + target.a * (1.0-source.a);\\n\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n\\n}\\n\\n\"\r\n    );\r\n    this.bind();\r\n    this.uniforms.uSampler = [0, 1];\r\n}\r\n\r\nOverlayShader.prototype = Object.create(PIXI.Shader.prototype);\r\nOverlayShader.prototype.constructor = OverlayShader;\r\nmodule.exports = OverlayShader;\r\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.tilemap\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n */\r\nfunction OverlayShader(gl)\r\n{\r\n    PIXI.Shader.call(this,\r\n        gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nuniform mat3 mapMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvarying vec2 vMapCoord;\\n\\nvoid main(void)\\n\\n{\\n\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\\n\\n    vTextureCoord = aTextureCoord;\\n\\n}\\n\\n\",\r\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying vec2 vMapCoord;\\n\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\n\\nuniform vec4 uTextureClamp;\\n\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n\\n{\\n\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n\\n    vec4 source = texture2D(uSampler[0], textureCoord);\\n\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\r\\n    //yeah, premultiplied\\r\\n    if (source.a == 0.0) {\\n\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n\\n        return;\\n\\n    }\\n\\n    vec3 Cb = source.rgb/source.a, Cs;\\n\\n    if (target.a > 0.0) {\\n\\n        Cs = target.rgb / target.a;\\n\\n    }\\n\\n    vec3 multiply = Cb * Cs * 2.0;\\n\\n    vec3 Cs2 = Cs * 2.0 - 1.0;\\n\\n    vec3 screen = Cb + Cs2 - Cb * Cs2;\\n\\n    vec3 B;\\n\\n    if (Cb.r <= 0.5) {\\n\\n        B.r = multiply.r;\\n\\n    } else {\\n\\n        B.r = screen.r;\\n\\n    }\\n\\n    if (Cb.g <= 0.5) {\\n\\n        B.g = multiply.g;\\n\\n    } else {\\n\\n        B.g = screen.g;\\n\\n    }\\n\\n    if (Cb.b <= 0.5) {\\n\\n        B.b = multiply.b;\\n\\n    } else {\\n\\n        B.b = screen.b;\\n\\n    }\\n\\n    vec4 res;\\n\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n\\n    res.a = source.a + target.a * (1.0-source.a);\\n\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n\\n}\\n\\n\"\r\n    );\r\n    this.bind();\r\n    this.uniforms.uSampler = [0, 1];\r\n}\r\n\r\nOverlayShader.prototype = Object.create(PIXI.Shader.prototype);\r\nOverlayShader.prototype.constructor = OverlayShader;\r\nmodule.exports = OverlayShader;\r\n\n},{}],2:[function(require,module,exports){\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.tilemap\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n */\r\nfunction OverlayShader(gl)\r\n{\r\n    PIXI.Shader.call(this,\r\n        gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nuniform mat3 mapMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvarying vec2 vMapCoord;\\n\\nvoid main(void)\\n\\n{\\n\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\\n\\n    vTextureCoord = aTextureCoord;\\n\\n}\\n\\n\",\r\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying vec2 vMapCoord;\\n\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\n\\nuniform vec4 uTextureClamp;\\n\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n\\n{\\n\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n\\n    vec4 source = texture2D(uSampler[0], textureCoord);\\n\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\r\\n    if (source.a == 0.0) {\\n\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n\\n        return;\\n\\n    }\\n\\n    //yeah, premultiplied\\r\\n    vec3 Cb = source.rgb/source.a, Cs;\\n\\n    if (target.a > 0.0) {\\n\\n        Cs = target.rgb / target.a;\\n\\n    }\\n\\n    vec3 multiply = Cb * Cs * 2.0;\\n\\n    vec3 Cb2 = Cb * 2.0 - 1.0;\\n\\n    vec3 screen = Cb2 + Cs - Cb2 * Cs;\\n\\n    vec3 B;\\n\\n    if (Cs.r <= 0.5) {\\n\\n        B.r = multiply.r;\\n\\n    } else {\\n\\n        B.r = screen.r;\\n\\n    }\\n\\n    if (Cs.g <= 0.5) {\\n\\n        B.g = multiply.g;\\n\\n    } else {\\n\\n        B.g = screen.g;\\n\\n    }\\n\\n    if (Cs.b <= 0.5) {\\n\\n        B.b = multiply.b;\\n\\n    } else {\\n\\n        B.b = screen.b;\\n\\n    }\\n\\n    vec4 res;\\n\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n\\n    res.a = source.a + target.a * (1.0-source.a);\\n\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n\\n}\\n\\n\"\r\n    );\r\n    this.bind();\r\n    this.uniforms.uSampler = [0, 1];\r\n}\r\n\r\nOverlayShader.prototype = Object.create(PIXI.Shader.prototype);\r\nOverlayShader.prototype.constructor = OverlayShader;\r\nmodule.exports = OverlayShader;\r\n\n},{}],3:[function(require,module,exports){\nvar PictureShader = require('./PictureShader'),\r\n    mapFilterBlendModesToPixi = require('./mapFilterBlendModesToPixi'),\r\n    glCore = PIXI.glCore;\r\n\r\n/**\r\n * Renderer that clamps the texture so neighbour frames wont bleed on it\r\n * immitates context2d drawImage behaviour\r\n *\r\n * @class\r\n * @memberof PIXI.extras\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {PIXI.WebGLRenderer} The renderer this plugin works for\r\n */\r\nfunction PictureRenderer(renderer) {\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n}\r\n\r\nPictureRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nPictureRenderer.prototype.constructor = PictureRenderer;\r\n\r\nPictureRenderer.prototype.onContextChange = function () {\r\n    var gl = this.renderer.gl;\r\n    this.quad = new PIXI.Quad(gl);\r\n    this.normalShader = new PictureShader(gl);\r\n    this.drawModes = mapFilterBlendModesToPixi(gl);\r\n    this.quad.initVao(this.normalShader);\r\n    this._tempClamp = new Float32Array(4);\r\n    this._tempColor = new Float32Array(4);\r\n    this._tempRect = new PIXI.Rectangle();\r\n    this._tempRect2 = new PIXI.Rectangle();\r\n    this._tempRect3 = new PIXI.Rectangle();\r\n    this._tempMatrix = new PIXI.Matrix();\r\n    this._bigBuf = new Uint8Array(1 << 20);\r\n    this._renderTexture = new PIXI.BaseRenderTexture(1024, 1024);\r\n};\r\n\r\nPictureRenderer.prototype.start = function () {\r\n    //noop\r\n};\r\n\r\nPictureRenderer.prototype.flush = function () {\r\n    //noop\r\n};\r\n\r\nfunction nextPow2(v) {\r\n    v += v === 0;\r\n    --v;\r\n    v |= v >>> 1;\r\n    v |= v >>> 2;\r\n    v |= v >>> 4;\r\n    v |= v >>> 8;\r\n    v |= v >>> 16;\r\n    return v + 1;\r\n}\r\n\r\nPictureRenderer.prototype._getRenderTexture = function (minWidth, minHeight) {\r\n    if (this._renderTexture.width < minWidth ||\r\n        this._renderTexture.height < minHeight) {\r\n        minHeight = nextPow2(minWidth);\r\n        minHeight = nextPow2(minHeight);\r\n        this._renderTexture.resize(minWidth, minHeight);\r\n    }\r\n    return this._renderTexture;\r\n};\r\n\r\nPictureRenderer.prototype._getBuf = function (size) {\r\n    var buf = this._bigBuf;\r\n    if (buf.length < size) {\r\n        size = nextPow2(size);\r\n        buf = new Uint8Array(size);\r\n        this._bigBuf = buf;\r\n    }\r\n    return buf;\r\n};\r\n\r\n/**\r\n * Renders the picture object.\r\n *\r\n * @param sprite {PIXI.tilemap.PictureSprite} the picture to render\r\n */\r\nPictureRenderer.prototype.render = function (sprite) {\r\n    if (!sprite.texture.valid) {\r\n        return;\r\n    }\r\n    var blendShader = this.drawModes[sprite.blendMode];\r\n    if (blendShader) {\r\n        this._renderBlend(sprite, blendShader);\r\n    } else {\r\n        this._renderNormal(sprite, this.normalShader);\r\n    }\r\n};\r\n\r\nPictureRenderer.prototype._renderNormal = function (sprite, shader) {\r\n    var renderer = this.renderer;\r\n    renderer.bindShader(shader);\r\n    renderer.state.setBlendMode(sprite.blendMode);\r\n    this._renderInner(sprite, shader);\r\n};\r\n\r\nPictureRenderer.prototype._renderBlend = function (sprite, shader) {\r\n    //nothing there yet\r\n    var renderer = this.renderer;\r\n    var spriteBounds = sprite.getBounds();\r\n    var renderTarget = renderer._activeRenderTarget;\r\n    var matrix = renderTarget.projectionMatrix;\r\n    var flipX = matrix.a < 0;\r\n    var flipY = matrix.d < 0;\r\n    var resolution = renderTarget.resolution;\r\n    var screen = this._tempRect;\r\n    var fr = renderTarget.sourceFrame || renderTarget.destinationFrame;\r\n    screen.x = 0;\r\n    screen.y = 0;\r\n    screen.width = fr.width;\r\n    screen.height = fr.height;\r\n\r\n    var bounds = this._tempRect2;\r\n    var fbw = fr.width * resolution, fbh = fr.height * resolution;\r\n    bounds.x = (spriteBounds.x + matrix.tx / matrix.a) * resolution + fbw / 2;\r\n    bounds.y = (spriteBounds.y + matrix.ty / matrix.d) * resolution + fbh / 2;\r\n    bounds.width = spriteBounds.width * resolution;\r\n    bounds.height = spriteBounds.height * resolution;\r\n    if (flipX) {\r\n        bounds.y = fbw - bounds.width - bounds.x;\r\n    }\r\n    if (flipY) {\r\n        bounds.y = fbh - bounds.height - bounds.y;\r\n    }\r\n\r\n    var screenBounds = this._tempRect3;\r\n    var x_1 = Math.floor(Math.max(screen.x, bounds.x));\r\n    var x_2 = Math.ceil(Math.min(screen.x + screen.width, bounds.x + bounds.width));\r\n    var y_1 = Math.floor(Math.max(screen.y, bounds.y));\r\n    var y_2 = Math.ceil(Math.min(screen.y + screen.height, bounds.y + bounds.height));\r\n    var pixelsWidth = x_2 - x_1;\r\n    var pixelsHeight = y_2 - y_1;\r\n    if (pixelsWidth <= 0 || pixelsHeight <= 0) {\r\n        //culling\r\n        return;\r\n    }\r\n    //TODO: padding\r\n    var rt = this._getRenderTexture(pixelsWidth, pixelsHeight);\r\n    renderer.bindTexture(rt, 1);\r\n    var gl = renderer.gl;\r\n    if (renderer.renderingToScreen && renderTarget.root) {\r\n        var buf = this._getBuf(pixelsWidth * pixelsHeight * 4);\r\n        gl.readPixels(x_1, y_1, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\r\n        //REVERT Y?\r\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\r\n    } else {\r\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x_1, y_1, pixelsWidth, pixelsHeight);\r\n    }\r\n\r\n    renderer.bindShader(shader);\r\n    renderer.state.setBlendMode(PIXI.BLEND_MODES.NORMAL);\r\n    if (shader.uniforms.mapMatrix) {\r\n        var mapMatrix = this._tempMatrix;\r\n        mapMatrix.a = bounds.width / rt.width / spriteBounds.width;\r\n        if (flipX) {\r\n            mapMatrix.a = -mapMatrix.a;\r\n            mapMatrix.ty = (bounds.x - x_1) / rt.width - (spriteBounds.x + spriteBounds.width) * mapMatrix.a;\r\n        } else {\r\n            mapMatrix.tx = (bounds.x - x_1) / rt.width - spriteBounds.x * mapMatrix.a;\r\n        }\r\n        mapMatrix.d = bounds.height / rt.height / spriteBounds.height;\r\n        if (flipY) {\r\n            mapMatrix.d = -mapMatrix.d;\r\n            mapMatrix.ty = (bounds.y - y_1) / rt.height - (spriteBounds.y + spriteBounds.height) * mapMatrix.d;\r\n        } else {\r\n            mapMatrix.ty = (bounds.y - y_1) / rt.height - spriteBounds.y * mapMatrix.d;\r\n        }\r\n\r\n        shader.uniforms.mapMatrix = mapMatrix.toArray(true, shader.uniforms.mapMatrix);\r\n    }\r\n\r\n    this._renderInner(sprite, shader);\r\n};\r\n\r\n\r\nPictureRenderer.prototype._renderInner = function (sprite, shader) {\r\n    var renderer = this.renderer;\r\n    var quad = this.quad;\r\n    var uvs = sprite.texture._uvs;\r\n\r\n    //sprite already has calculated the vertices. lets transfer them to quad\r\n\r\n    var vertices = quad.vertices;\r\n    var vd = sprite.computedGeometry ? sprite.computedGeometry.vertices : sprite.vertexData;\r\n    for (var i = 0; i < 8; i++) {\r\n        quad.vertices[i] = vd[i];\r\n    }\r\n\r\n    //SpriteRenderer works differently, with uint32 UVS\r\n    //but for our demo float uvs are just fine\r\n    quad.uvs[0] = uvs.x0;\r\n    quad.uvs[1] = uvs.y0;\r\n    quad.uvs[2] = uvs.x1;\r\n    quad.uvs[3] = uvs.y1;\r\n    quad.uvs[4] = uvs.x2;\r\n    quad.uvs[5] = uvs.y2;\r\n    quad.uvs[6] = uvs.x3;\r\n    quad.uvs[7] = uvs.y3;\r\n\r\n    //TODO: add baricentric coords here\r\n    quad.upload();\r\n\r\n    var frame = sprite.texture.frame;\r\n    var base = sprite.texture.baseTexture;\r\n    var clamp = this._tempClamp;\r\n    //clamping 0.5 pixel from each side to reduce border artifact\r\n    //this is our plugin main purpose\r\n    clamp[0] = frame.x / base.width + 0.5 / base.realWidth;\r\n    clamp[1] = frame.y / base.height + 0.5 / base.realWidth;\r\n    clamp[2] = (frame.x + frame.width) / base.width - 0.5 / base.realWidth;\r\n    clamp[3] = (frame.y + frame.height) / base.height - 0.5 / base.realWidth;\r\n    //take a notice that size in pixels is realWidth,realHeight\r\n    //width and height are divided by resolution\r\n    shader.uniforms.uTextureClamp = clamp;\r\n\r\n    var color = this._tempColor;\r\n    PIXI.utils.hex2rgb(sprite.tint, color);\r\n    var alpha = sprite.worldAlpha;\r\n    //premultiplied alpha tint\r\n    //of course we could do that in shader too\r\n    color[0] *= alpha;\r\n    color[1] *= alpha;\r\n    color[2] *= alpha;\r\n    color[3] = alpha;\r\n    shader.uniforms.uColor = color;\r\n\r\n    //bind texture to unit 0, our default sampler unit\r\n    renderer.bindTexture(base, 0);\r\n    quad.draw();\r\n};\r\n\r\nPIXI.WebGLRenderer.registerPlugin('picture', PictureRenderer);\r\n\r\nmodule.exports = PictureRenderer;\r\n\n},{\"./PictureShader\":4,\"./mapFilterBlendModesToPixi\":7}],4:[function(require,module,exports){\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.extras\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n */\r\nfunction PictureShader(gl)\r\n{\r\n    PIXI.Shader.call(this,\r\n        gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n\\n{\\n\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n\\n}\\n\\n\",\r\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nuniform vec4 uTextureClamp;\\n\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n\\n{\\n\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n\\n    vec4 sample = texture2D(uSampler, textureCoord);\\n\\n    gl_FragColor = sample * uColor;\\n\\n}\\n\\n\"\r\n    );\r\n    //do some stuff, like default values for shader\r\n    //dont forget to bind it if you really are changing the uniforms\r\n    this.bind();\r\n    //default tint\r\n    //Its an example, actually PictureRenderer takes care of this stuff\r\n    this.uniforms.uColor = new Float32Array(1,1,1,1);\r\n}\r\n\r\nPictureShader.prototype = Object.create(PIXI.Shader.prototype);\r\nPictureShader.prototype.constructor = PictureShader;\r\nmodule.exports = PictureShader;\r\n\n},{}],5:[function(require,module,exports){\n/**\r\n * A Sprite with reduced border artifacts\r\n *\r\n * @class\r\n * @extends PIXI.Sprite\r\n * @memberof PIXI.tilemap\r\n * @param texture {PIXI.Texture} the texture for this sprite\r\n */\r\nfunction PictureSprite(texture)\r\n{\r\n    PIXI.Sprite.call(this, texture);\r\n}\r\n\r\nPictureSprite.prototype = Object.create(PIXI.Sprite.prototype);\r\nPictureSprite.prototype.constructor = PictureSprite;\r\nmodule.exports = PictureSprite;\r\n\r\n/**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {PIXI.WebGLRenderer}\r\n * @private\r\n */\r\nPictureSprite.prototype._renderWebGL = function (renderer)\r\n{\r\n    if (this.updateGeometry) {\r\n        this.updateGeometry();\r\n    }\r\n\r\n    //use different plugin for rendering\r\n    renderer.setObjectRenderer(renderer.plugins.picture);\r\n    renderer.plugins.picture.render(this);\r\n};\r\n\n},{}],6:[function(require,module,exports){\nvar myPlugin = {\r\n    PictureSprite: require('./PictureSprite'),\r\n    PictureRenderer: require('./PictureRenderer')\r\n};\r\n\r\n//dump everything into extras\r\n\r\nObject.assign(PIXI.extras, myPlugin);\r\n\r\nmodule.exports = myPlugin;\r\n\n},{\"./PictureRenderer\":3,\"./PictureSprite\":5}],7:[function(require,module,exports){\nvar CONST = PIXI,\r\n    OverlayShader = require('./OverlayShader'),\r\n    HardLightShader = require('./HardLightShader');\r\n\r\n/**\r\n * Maps gl blend combinations to WebGL\r\n * @class\r\n * @memberof PIXI\r\n */\r\nfunction mapFilterBlendModesToPixi(gl, array)\r\n{\r\n    array = array || [];\r\n\r\n    //TODO - premultiply alpha would be different.\r\n    //add a boolean for that!\r\n    array[CONST.BLEND_MODES.OVERLAY] = new OverlayShader(gl);\r\n    array[CONST.BLEND_MODES.HARD_LIGHT] = new HardLightShader(gl);\r\n\r\n    return array;\r\n}\r\n\r\nmodule.exports = mapFilterBlendModesToPixi;\r\n\n},{\"./HardLightShader\":1,\"./OverlayShader\":2}]},{},[6])\n\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.tilemap\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n */\r\nfunction OverlayShader(gl)\r\n{\r\n    PIXI.Shader.call(this,\r\n        gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nuniform mat3 mapMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvarying vec2 vMapCoord;\\n\\nvoid main(void)\\n\\n{\\n\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\\n\\n    vTextureCoord = aTextureCoord;\\n\\n}\\n\\n\",\r\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying vec2 vMapCoord;\\n\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\n\\nuniform vec4 uTextureClamp;\\n\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n\\n{\\n\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n\\n    vec4 source = texture2D(uSampler[0], textureCoord);\\n\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\r\\n    if (source.a == 0.0) {\\n\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n\\n        return;\\n\\n    }\\n\\n    //yeah, premultiplied\\r\\n    vec3 Cb = source.rgb/source.a, Cs;\\n\\n    if (target.a > 0.0) {\\n\\n        Cs = target.rgb / target.a;\\n\\n    }\\n\\n    vec3 multiply = Cb * Cs * 2.0;\\n\\n    vec3 Cb2 = Cb * 2.0 - 1.0;\\n\\n    vec3 screen = Cb2 + Cs - Cb2 * Cs;\\n\\n    vec3 B;\\n\\n    if (Cs.r <= 0.5) {\\n\\n        B.r = multiply.r;\\n\\n    } else {\\n\\n        B.r = screen.r;\\n\\n    }\\n\\n    if (Cs.g <= 0.5) {\\n\\n        B.g = multiply.g;\\n\\n    } else {\\n\\n        B.g = screen.g;\\n\\n    }\\n\\n    if (Cs.b <= 0.5) {\\n\\n        B.b = multiply.b;\\n\\n    } else {\\n\\n        B.b = screen.b;\\n\\n    }\\n\\n    vec4 res;\\n\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n\\n    res.a = source.a + target.a * (1.0-source.a);\\n\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n\\n}\\n\\n\"\r\n    );\r\n    this.bind();\r\n    this.uniforms.uSampler = [0, 1];\r\n}\r\n\r\nOverlayShader.prototype = Object.create(PIXI.Shader.prototype);\r\nOverlayShader.prototype.constructor = OverlayShader;\r\nmodule.exports = OverlayShader;\r\n","var PictureShader = require('./PictureShader'),\r\n    mapFilterBlendModesToPixi = require('./mapFilterBlendModesToPixi'),\r\n    glCore = PIXI.glCore;\r\n\r\n/**\r\n * Renderer that clamps the texture so neighbour frames wont bleed on it\r\n * immitates context2d drawImage behaviour\r\n *\r\n * @class\r\n * @memberof PIXI.extras\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {PIXI.WebGLRenderer} The renderer this plugin works for\r\n */\r\nfunction PictureRenderer(renderer) {\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n}\r\n\r\nPictureRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nPictureRenderer.prototype.constructor = PictureRenderer;\r\n\r\nPictureRenderer.prototype.onContextChange = function () {\r\n    var gl = this.renderer.gl;\r\n    this.quad = new PIXI.Quad(gl);\r\n    this.normalShader = new PictureShader(gl);\r\n    this.drawModes = mapFilterBlendModesToPixi(gl);\r\n    this.quad.initVao(this.normalShader);\r\n    this._tempClamp = new Float32Array(4);\r\n    this._tempColor = new Float32Array(4);\r\n    this._tempRect = new PIXI.Rectangle();\r\n    this._tempRect2 = new PIXI.Rectangle();\r\n    this._tempRect3 = new PIXI.Rectangle();\r\n    this._tempMatrix = new PIXI.Matrix();\r\n    this._bigBuf = new Uint8Array(1 << 20);\r\n    this._renderTexture = new PIXI.BaseRenderTexture(1024, 1024);\r\n};\r\n\r\nPictureRenderer.prototype.start = function () {\r\n    //noop\r\n};\r\n\r\nPictureRenderer.prototype.flush = function () {\r\n    //noop\r\n};\r\n\r\nfunction nextPow2(v) {\r\n    v += v === 0;\r\n    --v;\r\n    v |= v >>> 1;\r\n    v |= v >>> 2;\r\n    v |= v >>> 4;\r\n    v |= v >>> 8;\r\n    v |= v >>> 16;\r\n    return v + 1;\r\n}\r\n\r\nPictureRenderer.prototype._getRenderTexture = function (minWidth, minHeight) {\r\n    if (this._renderTexture.width < minWidth ||\r\n        this._renderTexture.height < minHeight) {\r\n        minHeight = nextPow2(minWidth);\r\n        minHeight = nextPow2(minHeight);\r\n        this._renderTexture.resize(minWidth, minHeight);\r\n    }\r\n    return this._renderTexture;\r\n};\r\n\r\nPictureRenderer.prototype._getBuf = function (size) {\r\n    var buf = this._bigBuf;\r\n    if (buf.length < size) {\r\n        size = nextPow2(size);\r\n        buf = new Uint8Array(size);\r\n        this._bigBuf = buf;\r\n    }\r\n    return buf;\r\n};\r\n\r\n/**\r\n * Renders the picture object.\r\n *\r\n * @param sprite {PIXI.tilemap.PictureSprite} the picture to render\r\n */\r\nPictureRenderer.prototype.render = function (sprite) {\r\n    if (!sprite.texture.valid) {\r\n        return;\r\n    }\r\n    var blendShader = this.drawModes[sprite.blendMode];\r\n    if (blendShader) {\r\n        this._renderBlend(sprite, blendShader);\r\n    } else {\r\n        this._renderNormal(sprite, this.normalShader);\r\n    }\r\n};\r\n\r\nPictureRenderer.prototype._renderNormal = function (sprite, shader) {\r\n    var renderer = this.renderer;\r\n    renderer.bindShader(shader);\r\n    renderer.state.setBlendMode(sprite.blendMode);\r\n    this._renderInner(sprite, shader);\r\n};\r\n\r\nPictureRenderer.prototype._renderBlend = function (sprite, shader) {\r\n    //nothing there yet\r\n    var renderer = this.renderer;\r\n    var spriteBounds = sprite.getBounds();\r\n    var renderTarget = renderer._activeRenderTarget;\r\n    var matrix = renderTarget.projectionMatrix;\r\n    var flipX = matrix.a < 0;\r\n    var flipY = matrix.d < 0;\r\n    var resolution = renderTarget.resolution;\r\n    var screen = this._tempRect;\r\n    var fr = renderTarget.sourceFrame || renderTarget.destinationFrame;\r\n    screen.x = 0;\r\n    screen.y = 0;\r\n    screen.width = fr.width;\r\n    screen.height = fr.height;\r\n\r\n    var bounds = this._tempRect2;\r\n    var fbw = fr.width * resolution, fbh = fr.height * resolution;\r\n    bounds.x = (spriteBounds.x + matrix.tx / matrix.a) * resolution + fbw / 2;\r\n    bounds.y = (spriteBounds.y + matrix.ty / matrix.d) * resolution + fbh / 2;\r\n    bounds.width = spriteBounds.width * resolution;\r\n    bounds.height = spriteBounds.height * resolution;\r\n    if (flipX) {\r\n        bounds.y = fbw - bounds.width - bounds.x;\r\n    }\r\n    if (flipY) {\r\n        bounds.y = fbh - bounds.height - bounds.y;\r\n    }\r\n\r\n    var screenBounds = this._tempRect3;\r\n    var x_1 = Math.floor(Math.max(screen.x, bounds.x));\r\n    var x_2 = Math.ceil(Math.min(screen.x + screen.width, bounds.x + bounds.width));\r\n    var y_1 = Math.floor(Math.max(screen.y, bounds.y));\r\n    var y_2 = Math.ceil(Math.min(screen.y + screen.height, bounds.y + bounds.height));\r\n    var pixelsWidth = x_2 - x_1;\r\n    var pixelsHeight = y_2 - y_1;\r\n    if (pixelsWidth <= 0 || pixelsHeight <= 0) {\r\n        //culling\r\n        return;\r\n    }\r\n    //TODO: padding\r\n    var rt = this._getRenderTexture(pixelsWidth, pixelsHeight);\r\n    renderer.bindTexture(rt, 1);\r\n    var gl = renderer.gl;\r\n    if (renderer.renderingToScreen && renderTarget.root) {\r\n        var buf = this._getBuf(pixelsWidth * pixelsHeight * 4);\r\n        gl.readPixels(x_1, y_1, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\r\n        //REVERT Y?\r\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\r\n    } else {\r\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x_1, y_1, pixelsWidth, pixelsHeight);\r\n    }\r\n\r\n    renderer.bindShader(shader);\r\n    renderer.state.setBlendMode(PIXI.BLEND_MODES.NORMAL);\r\n    if (shader.uniforms.mapMatrix) {\r\n        var mapMatrix = this._tempMatrix;\r\n        mapMatrix.a = bounds.width / rt.width / spriteBounds.width;\r\n        if (flipX) {\r\n            mapMatrix.a = -mapMatrix.a;\r\n            mapMatrix.ty = (bounds.x - x_1) / rt.width - (spriteBounds.x + spriteBounds.width) * mapMatrix.a;\r\n        } else {\r\n            mapMatrix.tx = (bounds.x - x_1) / rt.width - spriteBounds.x * mapMatrix.a;\r\n        }\r\n        mapMatrix.d = bounds.height / rt.height / spriteBounds.height;\r\n        if (flipY) {\r\n            mapMatrix.d = -mapMatrix.d;\r\n            mapMatrix.ty = (bounds.y - y_1) / rt.height - (spriteBounds.y + spriteBounds.height) * mapMatrix.d;\r\n        } else {\r\n            mapMatrix.ty = (bounds.y - y_1) / rt.height - spriteBounds.y * mapMatrix.d;\r\n        }\r\n\r\n        shader.uniforms.mapMatrix = mapMatrix.toArray(true, shader.uniforms.mapMatrix);\r\n    }\r\n\r\n    this._renderInner(sprite, shader);\r\n};\r\n\r\n\r\nPictureRenderer.prototype._renderInner = function (sprite, shader) {\r\n    var renderer = this.renderer;\r\n    var quad = this.quad;\r\n    var uvs = sprite.texture._uvs;\r\n\r\n    //sprite already has calculated the vertices. lets transfer them to quad\r\n\r\n    var vertices = quad.vertices;\r\n    var vd = sprite.computedGeometry ? sprite.computedGeometry.vertices : sprite.vertexData;\r\n    for (var i = 0; i < 8; i++) {\r\n        quad.vertices[i] = vd[i];\r\n    }\r\n\r\n    //SpriteRenderer works differently, with uint32 UVS\r\n    //but for our demo float uvs are just fine\r\n    quad.uvs[0] = uvs.x0;\r\n    quad.uvs[1] = uvs.y0;\r\n    quad.uvs[2] = uvs.x1;\r\n    quad.uvs[3] = uvs.y1;\r\n    quad.uvs[4] = uvs.x2;\r\n    quad.uvs[5] = uvs.y2;\r\n    quad.uvs[6] = uvs.x3;\r\n    quad.uvs[7] = uvs.y3;\r\n\r\n    //TODO: add baricentric coords here\r\n    quad.upload();\r\n\r\n    var frame = sprite.texture.frame;\r\n    var base = sprite.texture.baseTexture;\r\n    var clamp = this._tempClamp;\r\n    //clamping 0.5 pixel from each side to reduce border artifact\r\n    //this is our plugin main purpose\r\n    clamp[0] = frame.x / base.width + 0.5 / base.realWidth;\r\n    clamp[1] = frame.y / base.height + 0.5 / base.realWidth;\r\n    clamp[2] = (frame.x + frame.width) / base.width - 0.5 / base.realWidth;\r\n    clamp[3] = (frame.y + frame.height) / base.height - 0.5 / base.realWidth;\r\n    //take a notice that size in pixels is realWidth,realHeight\r\n    //width and height are divided by resolution\r\n    shader.uniforms.uTextureClamp = clamp;\r\n\r\n    var color = this._tempColor;\r\n    PIXI.utils.hex2rgb(sprite.tint, color);\r\n    var alpha = sprite.worldAlpha;\r\n    //premultiplied alpha tint\r\n    //of course we could do that in shader too\r\n    color[0] *= alpha;\r\n    color[1] *= alpha;\r\n    color[2] *= alpha;\r\n    color[3] = alpha;\r\n    shader.uniforms.uColor = color;\r\n\r\n    //bind texture to unit 0, our default sampler unit\r\n    renderer.bindTexture(base, 0);\r\n    quad.draw();\r\n};\r\n\r\nPIXI.WebGLRenderer.registerPlugin('picture', PictureRenderer);\r\n\r\nmodule.exports = PictureRenderer;\r\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.extras\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n */\r\nfunction PictureShader(gl)\r\n{\r\n    PIXI.Shader.call(this,\r\n        gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n\\n{\\n\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n\\n}\\n\\n\",\r\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nuniform vec4 uTextureClamp;\\n\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n\\n{\\n\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n\\n    vec4 sample = texture2D(uSampler, textureCoord);\\n\\n    gl_FragColor = sample * uColor;\\n\\n}\\n\\n\"\r\n    );\r\n    //do some stuff, like default values for shader\r\n    //dont forget to bind it if you really are changing the uniforms\r\n    this.bind();\r\n    //default tint\r\n    //Its an example, actually PictureRenderer takes care of this stuff\r\n    this.uniforms.uColor = new Float32Array(1,1,1,1);\r\n}\r\n\r\nPictureShader.prototype = Object.create(PIXI.Shader.prototype);\r\nPictureShader.prototype.constructor = PictureShader;\r\nmodule.exports = PictureShader;\r\n","/**\r\n * A Sprite with reduced border artifacts\r\n *\r\n * @class\r\n * @extends PIXI.Sprite\r\n * @memberof PIXI.tilemap\r\n * @param texture {PIXI.Texture} the texture for this sprite\r\n */\r\nfunction PictureSprite(texture)\r\n{\r\n    PIXI.Sprite.call(this, texture);\r\n}\r\n\r\nPictureSprite.prototype = Object.create(PIXI.Sprite.prototype);\r\nPictureSprite.prototype.constructor = PictureSprite;\r\nmodule.exports = PictureSprite;\r\n\r\n/**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {PIXI.WebGLRenderer}\r\n * @private\r\n */\r\nPictureSprite.prototype._renderWebGL = function (renderer)\r\n{\r\n    if (this.updateGeometry) {\r\n        this.updateGeometry();\r\n    }\r\n\r\n    //use different plugin for rendering\r\n    renderer.setObjectRenderer(renderer.plugins.picture);\r\n    renderer.plugins.picture.render(this);\r\n};\r\n","var myPlugin = {\r\n    PictureSprite: require('./PictureSprite'),\r\n    PictureRenderer: require('./PictureRenderer')\r\n};\r\n\r\n//dump everything into extras\r\n\r\nObject.assign(PIXI.extras, myPlugin);\r\n\r\nmodule.exports = myPlugin;\r\n","var CONST = PIXI,\r\n    OverlayShader = require('./OverlayShader'),\r\n    HardLightShader = require('./HardLightShader');\r\n\r\n/**\r\n * Maps gl blend combinations to WebGL\r\n * @class\r\n * @memberof PIXI\r\n */\r\nfunction mapFilterBlendModesToPixi(gl, array)\r\n{\r\n    array = array || [];\r\n\r\n    //TODO - premultiply alpha would be different.\r\n    //add a boolean for that!\r\n    array[CONST.BLEND_MODES.OVERLAY] = new OverlayShader(gl);\r\n    array[CONST.BLEND_MODES.HARD_LIGHT] = new HardLightShader(gl);\r\n\r\n    return array;\r\n}\r\n\r\nmodule.exports = mapFilterBlendModesToPixi;\r\n"],"sourceRoot":"./"}